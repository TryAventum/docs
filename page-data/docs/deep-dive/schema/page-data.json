{"componentChunkName":"component---src-templates-doc-js","path":"/docs/deep-dive/schema/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Schema\",\n  \"date\": \"2020-03-22\",\n  \"order\": 153\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"How Aventum creates the schemas dynamically for the content?\"), mdx(\"p\", null, \"Since MongoDB schema-less so when you create a schema Aventum convert it to a schema understandable by MongoDB, however, if you used SQL based database like PostgreSQL or MySQL then here is a close description of what Aventum do to achieve the dynamic schema.\"), mdx(\"p\", null, \"On creating a schema Aventum creates a table with the name same as the name that you put when you created the schema, with the fields that you added however if the field is repeatable and the repeatable field is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Relation\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Upload\"), \" then Aventum considers this as many-to-many relationship and will create a third table with the name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${schemaName}-${reference}-${fieldName}\"), \" with columns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${reference}Id\"), \"(if the content has relation with itself like for example categories have child categories then this column will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"child${Reference}Id\"), \") and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${schemaName}Id\"), \" the reference here is the uploads table or the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"relation\"), \" table.\"), mdx(\"p\", null, \"If the repeatable field is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"select\"), \" field then Aventum will create a table for this field with the name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${schemaName}-${fieldName}-options\"), \" and save the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"select\"), \" field options within it, then will create another table with the name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${schemaName}-${fieldName}\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${schemaName}-${fieldName}-optionsId\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${schemaName}Id\"), \" columns.\"), mdx(\"p\", null, \"If the repeatable field is not a relation or select or upload then Aventum will create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${schemaName}-${fieldName}\"), \" table with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${schemaName}Id\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" columns and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" columns will have the same field type.\"), mdx(\"p\", null, \"The \\\"custom\\\" field will be saved as a JSON string in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"text\"), \" column type no matter if it was repealable or not.\"), mdx(\"p\", null, \"To see how Aventum creates these tables take a look at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AventumFolder/server/models/sql/schema.js\"), \"\\nTo see how Aventum saves the content data within these tables take a look at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AventumFolder/server/models/sql/content.js\"), \".\"), mdx(\"h2\", null, \"Where Aventum saves the schema settings?\"), mdx(\"p\", null, \"Aventum saves the schema settings in the schemas table/collection.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#how-aventum-creates-the-schemas-dynamically-for-the-content","title":"How Aventum creates the schemas dynamically for the content?"},{"url":"#where-aventum-saves-the-schema-settings","title":"Where Aventum saves the schema settings?"}]},"frontmatter":{"title":"Schema"}}},"pageContext":{"slug":"/docs/deep-dive/schema/","prev":{"fields":{"slug":"/docs/deep-dive/"},"frontmatter":{"title":"Introduction"}},"next":{"fields":{"slug":"/docs/deep-dive/roles-and-capabilities/"},"frontmatter":{"title":"Roles And Capabilities"}}}},"staticQueryHashes":["681094712"]}